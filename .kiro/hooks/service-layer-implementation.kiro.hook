{
  "enabled": true,
  "name": "Service Layer Architecture Implementation",
  "description": "Monitors service layer files and provides comprehensive guidance on implementing a proper service layer architecture in Laravel, including base service classes, action classes, DTOs, service container bindings, controller integration, and testing strategies. Helps refactor fat controllers into thin controllers with proper separation of concerns.",
  "version": "1.0",
  "when": {
    "type": "fileEdited",
    "patterns": [
      "app/Services/**/*.php",
      "app/Actions/**/*.php",
      "app/DTOs/**/*.php",
      "app/Http/Controllers/**/*.php",
      "app/Providers/AppServiceProvider.php"
    ]
  },
  "then": {
    "type": "askAgent",
    "prompt": "A service layer file has been modified. Provide comprehensive guidance on implementing a proper service layer architecture:\n\n- use MCP servers, use mcp services\n\nANALYZE THE CURRENT SITUATION:\n- Review the modified file and identify fat controller patterns\n- Identify duplicate business logic across controllers\n- Assess current separation of concerns\n- Identify complex features that need service layer extraction\n\nCREATE COMPLETE SERVICE LAYER ARCHITECTURE:\n\n1. BASE SERVICE CLASS (app/Services/BaseService.php):\n   - Abstract class with common properties and methods\n   - Standardized error handling approach\n   - Consistent response formatting (success/error)\n   - Logging strategy with context\n   - Transaction management helpers\n   - Example:\n   ```php\n   abstract class BaseService {\n       protected function executeInTransaction(callable $callback);\n       protected function handleException(\\Exception $e);\n       protected function success($data, string $message = '');\n       protected function error(string $message, $data = null);\n       protected function log(string $level, string $message, array $context = []);\n   }\n   ```\n\n2. SPECIFIC SERVICE CLASSES:\n   - BillingService: Invoice generation, tariff calculations, payment processing\n   - UserManagementService: User creation, role assignment, account operations\n   - MeterReadingService: Reading validation, consumption calculations, audit trails\n   Each service should:\n   - Extend BaseService\n   - Have single responsibility\n   - Use dependency injection\n   - Return standardized responses\n\n3. ACTION CLASSES (app/Actions/):\n   - Single responsibility pattern\n   - When to use Actions vs Services:\n     * Actions: Single atomic operation (CreateUserAction, SendEmailAction)\n     * Services: Orchestrate multiple actions (UserManagementService uses CreateUserAction)\n   - Example actions:\n     * CreateUserAction: Validates and creates user\n     * AssignRoleAction: Assigns role to user\n     * SendWelcomeEmailAction: Sends welcome email\n     * ProcessPaymentAction: Handles payment processing\n     * GenerateInvoiceAction: Creates single invoice\n   - Actions compose together in services\n\n4. DTOs (app/DTOs/):\n   - When to use: Passing complex data between layers\n   - Validation: Use Laravel validation in DTOs or Form Requests\n   - Examples:\n     * CreateUserDTO: name, email, password, role, tenant_id\n     * InvoiceGenerationDTO: property_id, billing_period, meter_readings\n     * MeterReadingDTO: meter_id, reading_value, reading_date\n   - Immutable objects with typed properties\n   - Factory methods for creation from arrays/requests\n\n5. SERVICE CONTAINER BINDING (app/Providers/AppServiceProvider.php):\n   ```php\n   public function register(): void {\n       // Interface binding for testability\n       $this->app->bind(BillingServiceInterface::class, BillingService::class);\n       \n       // Singleton for stateless services\n       $this->app->singleton(TariffResolver::class);\n       \n       // Instance binding for stateful services\n       $this->app->bind(InvoiceGenerator::class);\n   }\n   ```\n\n6. CONTROLLER INTEGRATION:\n   - Thin controllers that delegate to services\n   - Dependency injection in constructor\n   - Handle HTTP concerns only (validation, responses)\n   - Example:\n   ```php\n   public function __construct(\n       private BillingService $billingService,\n       private MeterReadingService $meterReadingService\n   ) {}\n   \n   public function store(StoreInvoiceRequest $request) {\n       $result = $this->billingService->generateInvoice(\n           InvoiceGenerationDTO::fromRequest($request)\n       );\n       \n       return $result->success \n           ? redirect()->route('invoices.show', $result->data)\n           : back()->withErrors($result->message);\n   }\n   ```\n\n7. TESTING STRATEGY:\n   - Unit tests for services (mock dependencies, no database)\n   - Mock actions and external dependencies\n   - Feature tests with real services and database\n   - Example service test:\n   ```php\n   test('billing service generates invoice with correct calculations', function () {\n       $mockTariffResolver = Mockery::mock(TariffResolver::class);\n       $service = new BillingService($mockTariffResolver);\n       \n       $result = $service->generateInvoice($dto);\n       \n       expect($result->success)->toBeTrue();\n   });\n   ```\n\nEXPLAIN ARCHITECTURAL DECISIONS:\n- When to use services vs actions vs helpers:\n  * Services: Complex business logic, multiple steps, orchestration\n  * Actions: Single atomic operations, reusable across services\n  * Helpers: Pure functions, no dependencies, utility operations\n  \n- Cross-service communication:\n  * Inject service dependencies via constructor\n  * Use events for loose coupling between domains\n  * Avoid circular dependencies\n  \n- Transaction boundaries:\n  * Services manage transactions for their operations\n  * Use BaseService::executeInTransaction()\n  * Rollback on any exception\n  \n- Error propagation:\n  * Services catch and wrap exceptions\n  * Return standardized error responses\n  * Log errors with context\n  * Controllers convert to HTTP responses\n  \n- Logging and monitoring:\n  * Log at service layer with business context\n  * Use structured logging (context arrays)\n  * Log entry/exit of critical operations\n  * Include tenant_id, user_id in context\n\nPROVIDE PRODUCTION-READY CODE:\n- Complete base service abstract class\n- 3 concrete service classes (Billing, UserManagement, MeterReading)\n- 5 action classes with real-world logic\n- 3 DTO classes with validation\n- Controller refactoring examples\n- Service provider bindings\n- Complete test suite (unit + feature)\n\nConsider the existing Laravel structure:\n- Existing services in app/Services/\n- Current controllers in app/Http/Controllers/\n- Form requests in app/Http/Requests/\n- Multi-tenancy with TenantScope\n- SQLite database with transactions\n\nMake all code production-ready with proper error handling, logging, and type safety."
  },
  "workspaceFolderName": "laravel",
  "shortName": "service-layer-implementation"
}