{
  "enabled": true,
  "name": "Complete Feature Architecture Generator",
  "description": "Generates complete production-ready Laravel feature architecture including migrations, models, services, controllers, form requests, API resources, DTOs, events, observers, exceptions, and routes with full code implementation following Laravel conventions and best practices",
  "version": "1",
  "when": {
    "type": "userPrompt"
  },
  "then": {
    "type": "askAgent",
    "prompt": "Generate a complete, production-ready Laravel feature architecture based on the user's requirements. Include:\n\n1. **Folder Structure**: Complete directory layout following Laravel conventions (app/Models, app/Services, app/Http/Controllers, app/Http/Requests, app/Http/Resources, app/Events, app/Listeners, app/Observers, app/Exceptions, app/DTOs, database/migrations, routes)\n\n2. **Database Migrations**: Full migration files with:\n   - Proper column types (use decimal for money, json for flexible data)\n   - Foreign key constraints with cascade rules\n   - Indexes on frequently queried columns (tenant_id, status, dates)\n   - Unique constraints where needed\n   - Timestamps and soft deletes where appropriate\n\n3. **Models**: Complete Eloquent models with:\n   - All relationships (hasMany, belongsTo, belongsToMany, morphMany, etc.)\n   - Casts for dates, json, enums, decimals\n   - Accessors and mutators for computed attributes\n   - Query scopes for common filters\n   - Validation rules as constants or methods\n   - Global scopes if multi-tenancy applies\n   - Protected $fillable or $guarded\n\n4. **Service Classes**: Business logic layer with:\n   - Clear separation: Services handle complex business logic, Controllers handle HTTP\n   - Dependency injection in constructors\n   - Type-hinted parameters and return types\n   - Transaction handling for multi-step operations\n   - Exception throwing for business rule violations\n\n5. **Repository Pattern** (if needed): Explain when to use:\n   - Complex query logic that's reused across services\n   - Need to swap data sources (testing, caching)\n   - Multiple query variations for same entity\n   - Otherwise, Eloquent models are sufficient\n\n6. **Controllers**: Both web and API versions with:\n   - Resource controllers for CRUD operations\n   - Single-action controllers for specific operations\n   - Thin controllers that delegate to services\n   - Proper HTTP status codes\n   - Authorization via policies\n\n7. **Form Request Classes**: Validation with:\n   - Rules array with all validation logic\n   - Custom error messages\n   - Authorization logic in authorize() method\n   - Custom validation methods if needed\n\n8. **API Resources**: Data transformation with:\n   - Resource classes for single models\n   - ResourceCollection for lists\n   - Conditional attributes\n   - Nested relationships\n\n9. **DTOs**: Data Transfer Objects for:\n   - Complex data passing between layers\n   - Type safety for service method parameters\n   - Immutable data structures\n\n10. **Events and Listeners**: Decoupled actions:\n    - Events for significant domain occurrences\n    - Listeners for side effects (emails, logging, notifications)\n    - Queued listeners for async processing\n\n11. **Observers**: Model lifecycle hooks:\n    - Creating/created for defaults and auditing\n    - Updating/updated for change tracking\n    - Deleting/deleted for cleanup\n\n12. **Custom Exceptions**: Domain-specific errors:\n    - Extend base Exception or custom base\n    - Meaningful error messages\n    - HTTP status codes for API responses\n\n13. **Routes**: Complete route definitions:\n    - web.php for Blade views\n    - api.php for API endpoints\n    - Route groups with middleware\n    - Resource routes where appropriate\n    - Named routes\n\nFor each component, provide:\n- **Complete, working code** (not outlines or pseudocode)\n- **Explanation of why this pattern was chosen**\n- **What problem it solves**\n- **When to deviate from this structure**\n- **Trade-offs made**\n\nConsider the existing project context:\n- Laravel 11 with PHP 8.2+\n- SQLite database with WAL mode\n- Multi-tenancy via TenantScope global scope\n- Pest PHP for testing\n- Alpine.js for frontend reactivity\n- Existing enums: PropertyType, MeterType, ServiceType, InvoiceStatus, UserRole, TariffType, TariffZone, WeekendLogic\n- Existing services: TariffResolver, BillingService, GyvatukasCalculator, MeterReadingService\n- Existing middleware: EnsureTenantContext, RoleMiddleware, CheckSubscriptionStatus\n\nEnsure all code follows:\n- PSR-12 code style\n- Type hints for all parameters and returns\n- DocBlocks for public methods\n- Enum usage for fixed value sets\n- Proper error handling\n- Database transactions where needed\n- Multi-tenancy patterns if applicable\n\nProvide production-ready code that can be directly implemented."
  }
}